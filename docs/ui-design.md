# UI Design Document

## Core Principles
- **Server-rendered HTML first**: All primary views are generated by FastAPI templates (`app/templates.py`) with inline CSS tuned for light/dark system themes.
- **Minimal vanilla JS**: Progressive enhancement only. A small inline script handles polling, mention hints, and optimistic UI inside the dashboard; every form still posts traditionally without JS.
- **File-backed state**: Conversations, index records, settings, and task queues read/write JSON files under `data/`, so the UI must tolerate eventual consistency and missing fields.
- **Fast iteration**: Keep everything self-contained (no bundler or external stylesheets) to enable quick layout changes while staying dependency-free.

## Primary Views

### Dashboard (`/`)
- **Layout**: CSS grid with a conversation rail on the left, chat workspace in the center, and a full-width priority queue footer. The grid stretches to the viewport (`body` flex + `main` grid).
- **Conversation list**: Server renders recent conversations with last-access metadata. A `Start new conversation` form posts to `/conversation/new`. The active ID is tracked via `data-active-conversation` for refresh polling.
- **Chat history**: Messages render with role-specific styling (`user`, `assistant`, `tool`). Reasoning blocks use `<details>` panels toggled by the enhancement script. Label buttons call `/conversation/{id}/label`.
- **Prompt composer**: Posting to `/conversation/{id}/send`. The mention helper still reacts to `@alias` patterns, but the hint below the textarea was removed to reclaim vertical space.
- **Status badges**: Worker/Idle/LLM badges reflect `/status` and `/health/llama` checks (5s cadence). Errors fall back to “offline” labels.
- **Task strip**: Bottom section shows the newest two completed tasks (left) and queued/running tasks (right) using `_render_task_card`. Each card presents three terse lines—task type/title, status (running lines append elapsed time), and agent—plus an `Open details` button; border colour still hints at priority. Completed lanes always render two placeholders when empty, while the queued lane keeps a single placeholder.
- **Polling model**: `/state?conversation={id}` returns HTML fragments plus signature hashes so the client only patches when data actually changes. Running tasks inject a 5-second tick marker into the signature so their elapsed timers refresh automatically, and the priority queue only re-renders when those signatures differ. Scroll locking and optimistic append preserve chat continuity.

### Settings (`/settings`)
- **Header**: Mirrors dashboard badges so operators can see worker idleness and model health before editing.
- **Agent primer**: Lists configured mention aliases at the top to reinforce how chat mentions map to agents.
- **Configuration form**: Classic HTML form POSTing to `/settings`. Fields cover API base URL/key/model, plus per-agent name/description/model/temperature/context/system prompt. Inline styles lean on dashed borders to highlight editable agent cards.
- **No custom JS required**: Form submits normally; success feedback is via a redirect back to `/settings`.

### Task Detail (`/tasks/{task_id}`)
- **Context card**: Summarizes status, priority, conversation link, and timestamps in a definition list.
- **Payload viewer**: Pretty-prints the underlying task record JSON in a styled `<pre>`. Provides a “← Back to dashboard” affordance.

### Help (`/help`)
- **Static guidance**: Clarifies conversation workflow, mention usage, queue behaviour, and settings expectations. Styled similarly to other pages for continuity.

## Interaction Contracts
- **Auto-refresh cadence**: Dashboard polls `/status`, `/health/llama`, and `/state` every five seconds; each request must stay idempotent and cheap.
- **Idle monitor**: When no prompts are sent for 30 seconds, the backend flips the idle badge and may enqueue summarisation tasks. UI simply reflects the badge state.
- **Reasoning reveal**: Assistant/tool entries can include hidden reasoning snippets. The enhancement script assigns toggle buttons—keep summary markup (`details[data-reasoning]`) intact for accessibility.
- **Agent mentions**: Template data must provide up to four agents with aliases. Missing aliases degrade to generated `agent-{n}` strings; the JS suggestion list reacts to whatever JSON array the backend emits.

## Data Expectations
- Conversations: `data/conversations/{conversation_id}.jsonl`
- Index: `data/index.jsonl` for titles/summaries/last-access timestamps
- Tasks: `data/tasks.jsonl` via `TaskService`, surfaced through `/state`
- Settings: `data/settings.json` managed by `SettingsManager`

## URL Map
- `/` → main dashboard (`render_dashboard`)
- `/conversation/new` (POST) → create conversation, redirect back
- `/conversation/{conversation_id}/send` (POST) → append message, redirect
- `/conversation/{conversation_id}/label` (POST) → store reward feedback
- `/settings` (GET/POST) → configuration view and handler
- `/tasks/{task_id}` (GET) → task detail sheet
- `/help` (GET) → static help page
- `/state` (GET, JSON) → dashboard fragments + status bundle
- `/status` & `/health/llama` (GET, JSON) → badge data for poller

## Validation Tips
```bash
# dashboard renders
curl -sS http://localhost:8000/ >/dev/null
# polling contract
curl -sS http://localhost:8000/state | jq '.status.worker_state'
```
